var documenterSearchIndex = {"docs":
[{"location":"#VectorizationBase.jl","page":"Home","title":"VectorizationBase.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [VectorizationBase]","category":"page"},{"location":"#VectorizationBase.CACHE_SIZE","page":"Home","title":"VectorizationBase.CACHE_SIZE","text":"L₁, L₂, L₃, L₄ cache size\n\n\n\n\n\n","category":"constant"},{"location":"#VectorizationBase.AbstractStridedPointer","page":"Home","title":"VectorizationBase.AbstractStridedPointer","text":"abstract type AbstractStridedPointer{T,N,C,B,R,X,O} end\n\nT: element type N: dimensionality C: contiguous dim B: batch size R: rank of strides X: strides O: offsets\n\n\n\n\n\n","category":"type"},{"location":"#VectorizationBase.GroupedStridedPointers","page":"Home","title":"VectorizationBase.GroupedStridedPointers","text":"P are the pointers I contains indexes into strides (dynamic) and X (static) X static strides\n\n\n\n\n\n","category":"type"},{"location":"#VectorizationBase.MM","page":"Home","title":"VectorizationBase.MM","text":"The name MM type refers to MM registers such as XMM, YMM, and ZMM. MMX from the original MMX SIMD instruction set is a [meaningless initialism](https://en.wikipedia.org/wiki/MMX(instruction_set)#Naming).\n\nThe MM{W,X} type is used to represent SIMD indexes of width W with stride X.\n\n\n\n\n\n","category":"type"},{"location":"#VectorizationBase.Unroll","page":"Home","title":"VectorizationBase.Unroll","text":"AU - Unrolled axis F - Factor, step size per unroll N - How many times is it unrolled AV - Vectorized axis W - vector width M - bitmask indicating whether each factor is masked i::I - index\n\n\n\n\n\n","category":"type"},{"location":"#VectorizationBase.align","page":"Home","title":"VectorizationBase.align","text":"align(x::Union{Int,Ptr}, [n])\n\nReturn aligned memory address with minimum increment. align assumes n is a power of 2.\n\n\n\n\n\n","category":"function"},{"location":"#VectorizationBase.bitselect-Tuple{Any,Any,Any}","page":"Home","title":"VectorizationBase.bitselect","text":"bitselect(m::Unsigned, x::Unsigned, y::Unsigned)\n\nIf you have AVX512, setbits of vector-arguments will select bits according to mask m, selecting from x if 0 and from y if 1. For scalar arguments, or vector arguments without AVX512, setbits requires the additional restrictions on y that all bits for which m is 1, y must be 0. That is for scalar arguments or vector arguments without AVX512, it requires the restriction that ((y ⊻ m) & m) == m\n\n\n\n\n\n","category":"method"},{"location":"#VectorizationBase.grouped_strided_pointer-Union{Tuple{G}, Tuple{N}, Tuple{Tuple{Vararg{AbstractArray,N}},Val{G}}} where G where N","page":"Home","title":"VectorizationBase.grouped_strided_pointer","text":"G is a tuple(tuple((Aind,A's dim),(Aind,A's dim)), ()) it gives the groups.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizationBase.inv_approx-Tuple{Any}","page":"Home","title":"VectorizationBase.inv_approx","text":"Fast approximate reciprocal.\n\nGuaranteed accurate to at least 2^-14 ≈ 6.103515625e-5.\n\nUseful for special funcion implementations.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizationBase.lazymul-Union{Tuple{N}, Tuple{I}, Tuple{StaticInt{I},Any,Tuple{Vararg{Any,N}}}} where N where I","page":"Home","title":"VectorizationBase.lazymul","text":"Basically:\n\nif I ∈ [3,5,7,9]     c[(I - 1) >> 1] else     b * I end\n\nbecause\n\nc = b .* [3, 5, 7, 9]\n\n\n\n\n\n","category":"method"},{"location":"#VectorizationBase.offset_ptr-Union{Tuple{T}, Tuple{Type{T},Symbol,Any,Int64,Int64,Int64,Int64,Int64,Bool}} where T","page":"Home","title":"VectorizationBase.offset_ptr","text":"An omnibus offset constructor.\n\nThe general motivation for generating the memory addresses as LLVM IR rather than combining multiple lllvmcall Julia functions is that we want to minimize the inttoptr and ptrtoint calculations as we go back and fourth. These can get in the way of some optimizations, such as memory address calculations. It is particulary import for gather and scatters, as these functions take a Vec{W,Ptr{T}} argument to load/store a Vec{W,T} to/from. If sizeof(T) < sizeof(Int), converting the <W x $(typ)* vectors of pointers in LLVM to integer vectors as they're represented in Julia will likely make them too large to fit in a single register, splitting the operation into multiple operations, forcing a corresponding split of the Vec{W,T} vector as well. This would all be avoided by not promoting/widenting the <W x $(typ)> into a vector of Ints.\n\nFor this last issue, an alternate workaround would be to wrap a Vec of 32-bit integers with a type that defines it as a pointer for use with internal llvmcall functions, but I haven't really explored this optimization.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizationBase.pause-Tuple{}","page":"Home","title":"VectorizationBase.pause","text":"pause()\n\nFor use in spin-and-wait loops, like spinlocks.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizationBase.promote_div-Tuple{Union{Integer, VectorizationBase.AbstractSIMD{var\"#s87\",var\"#s86\"} where var\"#s86\"<:Integer where var\"#s87\"},Union{Integer, VectorizationBase.AbstractSIMD{var\"#s85\",var\"#s84\"} where var\"#s84\"<:Integer where var\"#s85\"}}","page":"Home","title":"VectorizationBase.promote_div","text":"Promote, favoring <:Signed or <:Unsigned of first arg.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizationBase.unrolled_indicies-NTuple{6,Int64}","page":"Home","title":"VectorizationBase.unrolled_indicies","text":"Returns a vector of expressions for a set of unrolled indices.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizationBase.vrangeincr-Union{Tuple{F}, Tuple{O}, Tuple{I}, Tuple{W}, Tuple{Val{W},I,Val{O},Val{F}}} where F where O where I<:Integer where W","page":"Home","title":"VectorizationBase.vrangeincr","text":"vrange(::Val{W}, i::I, ::Val{O}, ::Val{F})\n\nW - Vector width i::I - dynamic offset O - static offset F - static multiplicative factor\n\n\n\n\n\n","category":"method"}]
}
